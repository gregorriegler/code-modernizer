import re
import subprocess

from .ls_tool import LsTool
from .cat_tool import CatTool
from .test_tool import TestTool
from .auto_generated_tool import AutoGeneratedTool
from .revert_tool import RevertTool

class ToolLibrary:
    def __init__(self):
        # Static tools (non-refactoring)
        static_tools = [
            LsTool(self.runcommand),
            CatTool(self.runcommand),
            TestTool(self.runcommand),
            RevertTool(self.runcommand)
        ]
        
        # Auto-discover refactoring tools from C#
        refactoring_tools = self._discover_refactoring_tools()
        
        self.tools = static_tools + refactoring_tools
        self._build_tool_dict()
    
    def _discover_refactoring_tools(self):
        """Automatically discover all available C# refactoring tools"""
        try:
            # Get list of available refactoring tools from C#
            result = subprocess.run(
                ['dotnet', 'run', '--project', 'refactoring-tools/RoslynRefactoring/RoslynRefactoring.csproj', '--', '--list-tools'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode != 0:
                # Fallback to known tools if --list-tools is not implemented
                known_tools = ['extract-method', 'inline-method', 'extract-collaborator-interface', 'break-hard-dependency']
                return [AutoGeneratedTool(tool_name, self.runcommand) for tool_name in known_tools]
            
            tool_names = result.stdout.strip().split('\n')
            return [AutoGeneratedTool(tool_name.strip(), self.runcommand) for tool_name in tool_names if tool_name.strip()]
            
        except Exception as e:
            print(f"Warning: Could not auto-discover refactoring tools: {e}")
            # Fallback to known tools
            known_tools = ['extract-method', 'inline-method', 'extract-collaborator-interface', 'break-hard-dependency']
            return [AutoGeneratedTool(tool_name, self.runcommand) for tool_name in known_tools]
    
    def _build_tool_dict(self):
        self.tool_dict = {tool.name: tool for tool in self.tools}
    
    def get_tool_info(self, tool_name=None):
        """Get comprehensive information about tools"""
        if tool_name:
            tool = self.tool_dict.get(tool_name)
            if not tool:
                return f"Tool '{tool_name}' not found. Available tools: {', '.join(self.tool_dict.keys())}"
            
            if hasattr(tool, 'get_usage_info'):
                return tool.get_usage_info()
            else:
                return f"Tool: {tool.name}\nDescription: {getattr(tool, 'description', 'No description available')}"
        else:
            # List all tools with their descriptions
            info_lines = ["Available Tools:"]
            for tool in self.tools:
                description = getattr(tool, 'description', 'No description available')
                info_lines.append(f"  {tool.name}: {description}")
            return "\n".join(info_lines)
    
    def get_refactoring_tools_info(self):
        """Get detailed information about all refactoring tools"""
        refactoring_tools = [tool for tool in self.tools if hasattr(tool, 'info')]
        if not refactoring_tools:
            return "No refactoring tools found."
        
        info_lines = ["Refactoring Tools (auto-discovered from C#):"]
        for tool in refactoring_tools:
            info_lines.append(f"\n{tool.get_usage_info()}")
        
        return "\n".join(info_lines)
        
    def parse_and_execute(self, text):
        pattern = r'^/([\w-]+)(?:\s+(.*))?$'
        for line in text.splitlines():
            line = line.strip()
            match = re.match(pattern, line)
            if match:
                cmd, arg = match.groups()
                tool = self.tool_dict.get(cmd)
                if tool:
                    result = tool.execute(arg.strip() if arg else None)
                    return line, result['output']
                else:
                    return line, f"Unknown command: {cmd}"
        return text.splitlines()[0].strip(), ""

    def runcommand(self, cmd, args=None, cwd=None):
        try:
            if args:
                if isinstance(args, str):
                    args = [args]
                command_line = [cmd] + args
    
            result = subprocess.run(
                command_line,
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',
                timeout=30,
                cwd=cwd
            )
    
            output = result.stdout
            print(output, end='')
            if result.stderr:
                stderr = result.stderr
                print(f"\nSTDERR: {stderr}", end='')
                output += f"\nSTDERR: {stderr}"
    
            return {
                'success': result.returncode == 0,
                'output': output.strip(),
                'returncode': result.returncode
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'output': 'Command timed out (30s limit)', 'returncode': -1}
        except Exception as e:
            return {'success': False, 'output': f'Error: {str(e)}', 'returncode': -1}
